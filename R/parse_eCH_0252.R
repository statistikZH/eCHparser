#' Convert eCH-0252 XML file into a dataframe
#'
#'`parse_eCH_0252()` turns an eCH-0252 XML file for a vote into a dataframe.
#' Currently, the function supports input files for votes generated by the
#' applications VOTING and VeWork.
#'
#' @param file Path to your XML file
#' @param doi Domains of influence of the votes that you want included.
#' [eCH-0155](https://www.ech.ch/de/ech/ech-0155/4.1) defines the following domains of influence:
#' * CH = Bund
#' * CT = Kanton
#' * BZ = Bezirk / Amt / Verwaltungskreis
#' * MU = Gemeinde
#' * SC = Schulgemeinde
#' * KI = Kirchgemeinde
#' * OG = Ortsb√ºrgergemeinden
#' * KO = Korporationen
#' * SK = Stadtkreis
#' * AN = andere
#'
#' @return A dataframe
#' @export
#'
#' @examples
#' \dontrun{
#' filepath <- system.file("inst/extdata", "eCH_0252_vote_partial_abraxas.xml", package = "eCHparser")
#' votedata <- parse_eCH_0252(filepath, doi = c("CH", "CT", "MU"))
#' }
parse_eCH_0252 <- function(file, doi = c("CH", "CT")){

  # load file
  xml_data <- xml2::read_xml(file)

  # define namespaces
  namespaces <- xml2::xml_ns(xml_data)

  # define the prefixes we need (depends on exact file structure)
  ns0155 <- names(namespaces[grep("155", namespaces)])[1]
  ns0252 <- names(namespaces[grep("252", namespaces)])[1]

  # load base delivery part of the file
  node_voteBaseDelivery <- xml2::xml_find_first(xml_data, paste0(".//", ns0252, ":voteBaseDelivery"))

  # define canton id
  canton_id <- xml2::xml_find_first(node_voteBaseDelivery, paste0(".//", ns0252, ":cantonId")) |>
    xml2::xml_integer()

  # define polling day
  polling_day <- xml2::xml_find_first(node_voteBaseDelivery, paste0(".//", ns0252, ":pollingDay")) |>
    xml2::xml_text()

  # define domain of influence types found in data
  domainofOnfluenceType <- xml2::xml_find_all(node_voteBaseDelivery, paste0(".//", ns0252, ":domainOfInfluence")) |>
    xml2::xml_find_all(paste0(".//", ns0155, ":domainOfInfluenceType")) |>
    xml2::xml_text()

  # define index of votes with the relevant domain of influence types (must be +2 since the first two nodes are not of interest)
  relevant <- which(grepl(paste0(doi, collapse = "|"), domainofOnfluenceType)) + 2

  # stop if there are no relevant votes
  if (length(relevant) == 0) {
    stop("There are no votes matching your defined domains of influence (doi).")
  }

  # transform relevant data to list
  out_list <- lapply(relevant, function(x) read_voteInfo(node_voteBaseDelivery, x, canton_id, polling_day))

  # transform relevant data to df
  out_df <- dplyr::bind_rows(out_list)

  return(out_df)
}





#' Read eCH-0252 voteInfo node
#'
#' @param xml_node Node voteBaseDelivery of the XML file.
#' @param index index of the voteInfo nodes of interest.
#' @param canton_id Canton ID of interest.
#' @param polling_day Polling day of interest.
#'
#' @return A dataframe
#' @export
#'
#' @examples
#' \dontrun{
#' read_voteInfo(node_voteBaseDelivery, c(3, 4), 1, "2024-09-22")
#' }
read_voteInfo <- function(xml_node, index, canton_id, polling_day){

  # get structure of the indexed node as a list
  voteInfo <- xml2::xml_child(xml_node, index) |>
    xml2::as_list()

  # number the names to create unique names
  names(voteInfo) <- paste0(1:length(voteInfo),"_", names(voteInfo))

  # unlist the list
  voteInfo_unlist <- unlist(voteInfo)

  # list to df and add unique id
  voteInfo_df_long <- to_df(voteInfo_unlist, names(voteInfo_unlist)) |>
    dplyr::mutate(unique_id = gsub("^(\\d+)_.*", "\\1", var)) |>
    dplyr::mutate(var_short = gsub("\\d_", "", var_short))

  # define vote information
  vote_info <- voteInfo_df_long |>
    dplyr::filter(grepl("vote\\.", var)) |>
    to_wide() |>
    dplyr::select(-unique_id) |>
    tidyr::unnest_longer(everything())

  # define vote results
  vote_result <- voteInfo_df_long |>
    dplyr::filter(!grepl("vote\\.", var)) |>
    to_wide()

  # deal with nested nodes (seem to exist to add additional non-defined information that cannot be put in an element of the standard)
  if ("namedElement_elementName" %in% names(vote_result) || "subtotalInfo_countOfVoters" %in% names(vote_result)){

    # handle namedElement
    if ("namedElement_elementName" %in% names(vote_result)) {

      element_name <- vote_result |>
        dplyr::select(unique_id, namedElement_elementName, namedElement_text) |>
        tidyr::unnest_longer(everything()) |>
        tidyr::pivot_wider(names_from = namedElement_elementName, values_from = namedElement_text) |>
        tidyr::unnest_longer(everything())

      vote_result_full <- vote_result |>
        dplyr::select(-namedElement_elementName, -namedElement_text) |>
        tidyr::unnest_longer(everything(), keep_empty = TRUE) |>
        dplyr::mutate(vote_voteIdentification = vote_info$vote_voteIdentification) |>
        dplyr::left_join(element_name, by = "unique_id")

    }

    if ("subtotalInfo_countOfVoters" %in% names(vote_result)) {

      voter_type_sex <- vote_result |>
        dplyr::select(unique_id, subtotalInfo_countOfVoters, subtotalInfo_voterType, subtotalInfo_sex) |>
        tidyr::unnest_longer(everything()) #|>
      #   tidyr::pivot_wider(names_from = namedElement_elementName, values_from = namedElement_text) |>
      #   tidyr::unnest_longer(everything())
      #
      # vote_result_full <- vote_result |>
      #   dplyr::select(-namedElement_elementName, -namedElement_text) |>
      #   tidyr::unnest_longer(everything(), keep_empty = TRUE) |>
      #   dplyr::mutate(vote_voteIdentification = vote_info$vote_voteIdentification) |>
      #   dplyr::left_join(element_name, by = "unique_id")
















      count_of_voters_info <- xml2::xml_find_first(xml_node, "//eCH-0252:countOfVotersInformation")

      # Extract total count
      total_count <- xml2::xml_text(xml2::xml_find_first(count_of_voters_info, "./eCH-0252:countOfVotersTotal"))

      # Extract all "subtotalInfo" nodes
      subtotal_nodes <- xml2::xml_find_all(count_of_voters_info, "./eCH-0252:subtotalInfo")

      # Define desired structure
      desired_columns <- c("countOfVoters", "voterType", "sex")

      subtotal_info_list <- list(
        data.frame(
          countOfVoters = NA_character_,
          voterType = NA_character_,
          sex = NA_character_
        )
      )

      # Parse each "subtotalInfo" node into a data frame
      parse_subtotal <- function(node, columns) {
        # Extract all children of the node
        children <- xml2::xml_children(node)

        # Create a named list with element names as keys and their text as values
        data <- setNames(xml2::xml_text(children), xml2::xml_name(children))

        # Turn into data frame
        data_tbl <- as.data.frame(t(data), stringsAsFactors = FALSE)

      }

      # Apply parsing function to all "subtotalInfo" nodes
      subtotal_info_list <- c(subtotal_info_list, lapply(subtotal_nodes, parse_subtotal, columns = desired_columns))

      # Unlist
      subtotal_info <- do.call(dplyr::bind_rows, subtotal_info_list)

      # Drop first row
      subtotal_info <- subtotal_info[-1, ]



      # Add total count to the table
      result <- subtotal_info %>%
        dplyr::mutate(countOfVotersTotal = total_count)

      # View the final table
      print(result)












    }


  } else {

    vote_result_full <- vote_result |>
      tidyr::unnest_longer(everything(), keep_empty = TRUE) |>
      dplyr::mutate(vote_voteIdentification = vote_info$vote_voteIdentification)

  }

  # join result and information data
  vote_data_complete <- vote_result_full |>
    dplyr::left_join(vote_info, by = "vote_voteIdentification") |>
    dplyr::mutate(canotonId = canton_id,
                  pollingDay = polling_day)

  return(vote_data_complete)
}





#' Convert long dataframe to wide
#'
#' @param data A long dataframe
#'
#' @return A dataframe
#'
#' @examples
#' \dontrun{
#' to_wide(voteInfo_df_long)
#' }
to_wide <- function(data){

  if ("var" %in% names(data)){
    data <- data |>
      # delete var to make the pivot work
      dplyr::select(-var)
  }

  data |>
    tidyr::pivot_wider(
      names_from = var_short,
      values_from = data,
      values_fn = list
    )

}





#' Unlist list to dataframe
#'
#' @param data A dataframe
#' @param names Variable names
#'
#' @return A dataframe
#'
#' @examples
#' \dontrun{
#' to_df(voteInfo_unlist, names(voteInfo_unlist))
#' }
to_df <- function(data, names){

  data.frame(
    data = data,
    var = names
  ) |>
    dplyr::mutate(
      # search pattern starts at the end of the string and searches for the
      # first two dots. it returns the string in the brackets.
      # "datei.name.txt" --> "name.txt"
      var_short = gsub(".*\\.(.*\\..*)$", "\\1", var)
    ) |>
    dplyr::mutate(var_short = gsub("\\.", "_", var_short))
}

